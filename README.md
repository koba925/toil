# toil

学習用の言語処理系について、実装しながら考えたり検証したりします。

## 狙い

[350行くらいのPythonで作るプログラミング言語実装超入門](https://zenn.dev/kb84tkhr/books/mini-interpreter-in-350-lines)（以下「350行言語」）のような書籍のネタにするための言語処理系を考える。

以下のような点で差異化する。

* 最初に評価器を作る。
  350行言語では、なぜ構文解析が出てくるのかうまく説明できなかった。
  最初に、コンピュータで処理しやすい形から入り、その後人間のための形を追加するという流れにする。
* 最初の評価器はとにかく小さく作り、最初の敷居を下げる。ここだけ読んでも意義があるようにする。
* 最終的な行数にはこだわらない。
* マクロを導入する。
* 簡易的なカスタム文法を導入する。
* ツリーウォーク型の処理系だけではなく、中間言語へのコンパイル＋仮想マシンの形でも実装する。

以下の点は継続する。

* できるだけ平易なコードを書く。
* できるだけ予備知識を減らす。
* エラー処理や性能については問わず、言語処理系の原理の学習に的を絞る。

## これまでの実験

これまでの実験は以下にある。

* https://github.com/koba925/toig
* [トイ言語実験日記（マクロと継続）](https://zenn.dev/kb84tkhr/scraps/133254ba6599e4)
* [トイ言語実験日記２（構文解析とカスタム文法）](https://zenn.dev/kb84tkhr/scraps/344aa65443b4f3)
* [トイ言語実験日記３（ステートマシンでマクロと継続）](https://zenn.dev/kb84tkhr/scraps/446dd0e90c3fc3)
* [トイ言語実験日記４（テーマ未定)](https://zenn.dev/kb84tkhr/scraps/6f94737d864eef)
* [トイ言語実験日記５（中間コードインタプリタ）](https://zenn.dev/kb84tkhr/scraps/6903a2797fee46)
* [トイ言語実験日記６（toigでeval）](https://zenn.dev/kb84tkhr/scraps/9ea61135b3c146)

## 開発方針

* 言語処理系の原理を学習することを主要な目的とし、そのための最小限の実装を行う。
* 細かいステップでインクリメンタルに開発する。
* 標準・サードパーティ問わずライブラリの利用はできるだけ控える。ただしテスト用にpytestのみ導入する。
* 「後で必要になるから」と必然性のないコードはできるだけ入れないようにし、必要になったときに初めてコードを追加する。ただし、以下については先を見越してコードを書く場合もある。
  * 最終系のプログラムの骨組みを意識して書く。
  * 状態を持たず関数で実装できる場合でもクラス＋メソッドで書く。
    * 関心の分離を明確に表すため
    * 名前空間をクリーンに保つため
    * 一貫性を持つため
  * その他、あとで大量の書き直しが発生すると予想される場合。

## アーキテクチャ

## 現在の言語機能

* **データ型**: 整数、ブーリアン、None、関数（クロージャ）、配列、文字列
* **制御構文**: `if-then-elif-else-end`, `while-do-end`
* **変数**: `:=`による定義、`=`による代入、静的スコープ（クロージャ）
* **演算子**:
  * 四則演算: `+`, `-`, `*`, `/`, `%`
  * 比較演算: `==`, `!=`, `<`, `>`, `<=`, `>=`
  * 論理演算: `and`, `or`（短絡評価）, `not`
* **配列**:
  * `arr()`による生成、`[]`によるインデックスアクセス（負数インデックスも可）
  * `len`, `push`, `pop`, `slice` などの組み込み関数
* **文字列**:
  * シングルクォート (`'...'`): エスケープなしの生文字列
  * ダブルクォート (`"..."`): `\n`, `\"`, `\\` などのエスケープシーケンスが利用可能
  * `str`, `int`, `chr`, `ord`, `join` などの組み込み関数
* **標準ライブラリ**:
  * `toil`言語自身で実装されたライブラリ群
  * 高階関数: `map`, `filter`, `reduce`
  * ユーティリティ: `range`, `zip`, `enumerate`, `reverse`, `first`, `rest`, `last`

## 開発ステップ・

以下のような段階を踏んで開発を進める。
書籍にするときの流れを想定しているため、コミットの順番は一部これとは異なる箇所もある。

* 基本の評価器
  * 方針
    * 字句解析からは始めない。動かせるものから始める。
    * シンプルなツリーウォーク式評価器として実装する。
    * 扱う値はNone、bool、intのみ。Pythonの値をそのまま用いる。
    * この段階では文字列でシンボルを表す。
      * 字句解析・構文解析を導入する段階でシンボルを表す型を導入して文字列が文字列を表すようにする。
    * ASTはタプルで表す。
    * 環境はdictを用い、ミュータブルな構造として実装する。
  * 値を実装する。
  * 複数の式を順番に評価するseqを実装する。
  * ifを実装する。
  * 変数（定義・参照・代入）を評価する。まずはスコープなしで実装する。
  * 組み込み関数を実装する。
  * whileを実装する。
  * スコープを実装する。
    * 当初は動的スコープで実装し、後に静的スコープ（クロージャ）へ移行する。
  * ユーザ定義関数（動的スコープ）を実装する。
  * ユーザ定義関数（静的スコープ）を実装する。
* 余談：クロージャでデータ構造
* 余談：セルフ評価器
  * quoteを実装する。
  * セルフ評価器を実装する。
* 基本の字句解析・構文解析
  * 方針
    * 構文解析の学習のため、四則演算や比較などは演算子で表し、優先度も持たせる。
    * 演算子は構文解析で組み込み関数に変換する。
  * 数を実装する。
  * コメントを実装する。
  * 足し算、引き算を実装する。
  * 掛け算、割り算、剰余を実装する。
  * カッコを実装する。
  * 等号、不等号を実装する。
  * None、bool、シンボルを実装する。
  * 変数の定義・代入・参照を実装する。
  * ifの構文解析を実装する。
  * seqを実装する。
    * セミコロンを演算子として実装する。
  * 関数定義 deffunc ... params ... do ... endを実装する。
    * 変数定義と無名関数に変換することで構文糖衣として実装する。
  * elifを実装する。
    * 入れ子のif-then-elseに変換することで構文糖衣として実装する。
  * and、or（短絡評価）を実装する
    * ifに変換することで構文糖衣として実装する。
  * REPLとファイルからの実行を実装する。
* 機能を拡張する。
  * シンボルの表現を文字列からSymクラス、式の表現をタプルからExprクラスに変更する。
    * 配列・文字列の実装の準備。
  * 配列を実装する。
    * 配列の生成にはarr()関数を用い、特別な構文は用意しない。
    * 参照には[]を用いる。
    * 多次元配列もサポートする。
    * 要素への代入もサポートする。
    * `len`, `push`, `pop`, `slice` などの基本的な組み込み関数を実装する。
  * 標準ライブラリを実装する。
    * `toil`言語自身で`map`, `filter`, `reduce`などの高階関数や、`range`, `zip`, `first`などを実装する。
  * 文字列を実装する。
    * シングルクォート (`'...'`)による生文字列と、ダブルクォート (`"..."`)によるエスケープ可能な文字列の2種類を実装する。
    * 配列と同様の組み込み関数 (`len`, `slice`など) や、`str`, `int`, `chr`, `ord`, `join`などを実装する。
  * breakを実装する。
  * continueを実装する。
  * returnを実装する。
  * 可変長引数・分割代入・パターンマッチを実装する。
    * 関数のパラメータもパターンマッチできるようにしたい。
    * 進め方は要検討。
  * モジュール（ファイルからの読み込み）を実装する。
  * 辞書・UFCSを実装する？
    * オブジェクト風の表記が可能になる。
* マクロ・カスタム文法を実装する。
  * sym()、expr()でシンボル・式を直接生成できるようにする。
  * quasiquote相当の
  * この段階では関数に近い実装で、評価中にマクロを展開するようにする。
* カスタム文法を実装する。
  * マクロとカスタム文法で関数定義 deffunc を実装しなおす。
  * マクロでdefmacroを実装する。
  * マクロでelifを実装する。
  * マクロでanaphoric-ifを実装する。
  * anaphoric-ifを使ってand、orを実装する。
* 中間コードインタプリタとして実装する。
  * 方針
    * 中間言語へコンパイルして仮想マシンで動かす。
    * 仮想マシンはスタックマシンとして実装する。
    * 字句解析・構文解析はそのまま利用する。
    * 仮想マシンをゼロから実装しつつ、値、if、・・・とやはりインクリメンタルに実装する。
  * マクロ以外の機能を実装する。
  * 事前に展開する形のマクロを実装する。
    * 構文解析と実行の間にマクロ展開のフェーズを入れてASTを変換する。
  * 継続を実装する。
    * 継続でbreak、continue、returnを実装する。
* セルフインタプリタを書く。

# コーディング規約

* 書籍で説明する予定であることと、コードを短く見通しよくしたいことからコードにはコメントを入れない。
  * コメントを入れなくても読みやすいコードになるよう心がける。
  * ただし、変数名や関数名は長すぎないようにする。
* エラーはassertで上げる。エラーメッセージは f"{メッセージ} @ {関数}() : {エラーとなった値}"とする。
* 引用符はダブルクォーテーションを使う。
  * toilのソースコードは三重ダブルクォーテーションで囲んで記述する（toilのソースコードに引用符を使うようになることを見越して）。
* 見通せる範囲の情報量を増やすため、PEP-8にしたがえば改行を入れるところでも入れない場合がある。
  特に、トップレベルの定義の間は基本的には1行のみ（大きな区切りでは2行にすることもある）。
* 0や1はFalse・Trueやその他の特別な値と混乱する場合があるため、テストで使う数は2から始める。
* toil.pyのメインセクションには動作例となるコードを書きます。
* できるだけ、Interpreter.go()メソッドでテストを行い、go()でテストできない場合のみscan()、parse()、evaluate()でテストするようにします。ただし、初出の場合など説明のためにあえてgo()以外の動作例やテストを書く場合があります。また、すでに作成したテストは消さずに残します。
